---
title: "Introduction into machine learning and analysis of Breast Cancer Proteomes"
author: "Mats Slik"
email: "m.p.slik@st.hanze.nl"

output: pdf_document

---

<!-- (Front page) -->
\vspace{350pt}

\hfill \textbf{Student}: Mats Slik

\hfill \textbf{Student number}: 344216

\hfill \textbf{Class}: BFV3

\hfill \textbf{Study}: Bioinformatics

\hfill \textbf{Institute}: Institute for Life Science & Technology

\hfill \textbf{Teachers}: Dave Langers (LADR) and Bart Barnard (BABA)

\hfill \textbf{Date}: `r Sys.Date()`

\newpage
<!-- (Table of contents) -->
\setcounter{secnumdepth}{2}
\tableofcontents
\pagenumbering{arabic}

```{r setup, include = 0}

# packages
library(pander)
library(tidyr)
library(dplyr)
library(ggplot2)
library(ggExtra)
library(gridExtra)
library(stringr)
library(hrbrthemes)
library(viridis)
library(RWeka)
library(MatrixGenerics)
library(here)
library(smotefamily)
library(recipes)
library(caret)
library(RWeka)


knitr::opts_knit$set(root.dir = here::here())
```

\newpage
# Dataset



## About Dataset

### information about the data set and the three given files :
**Context:**
This data set contains published iTRAQ proteome profiling of 77 breast cancer samples generated by the Clinical Proteomic Tumor Analysis Consortium (NCI/NIH). It contains expression values for ~12.000 proteins for each sample, with missing values present when a given protein could not be quantified in a given sample.
this data was sampled from 105 originally from the TCGA (The Cancer Genome Atlas Program - NCI), which was further filterd to 77 samples containing high quality protein expression data.
**Content:**

* **File:** 77cancerproteomesCPTACitraq.csv

  + **RefSeqaccessionnumber:** RefSeq protein ID (each protein has a unique
  ID in a RefSeq database)
  + **gene_symbol:** a symbol unique to each gene (every protein is encoded
  by some gene)
  + **gene_name:** a full name of that gene
  + **Remaining columns:** log2 iTRAQ ratios for each sample (protein
  expression data, most important), three last columns are from healthy
  individuals


* **File:** clinicaldatabreast_cancer.csv

  + **First column** "Complete TCGA ID" is used to match the sample IDs in the main cancer proteomes file (see example script).
  + **All other columns** have self-explanatory names, contain data about the cancer classification of a given sample using different methods. 'PAM50 mRNA' classification is being used in the example script.

* **File:** PAM50_proteins.csv

    * **Contains**  the list of genes and proteins used by the PAM50 classification system. The column RefSeqProteinID contains the protein IDs that can be matched with the IDs in the main protein expression data set.

**Past Research:**
Original research paper: https://www.researchgate.net/publication/303509927_Proteogenomics_connects_somatic_mutations_to_signaling_in_breast_cancer

**Summary:** the data were used to assess how the mutations in the DNA are affecting the protein expression landscape in breast cancer. Genes in our DNA are first transcribed into RNA molecules which then are translated into proteins. Changing the information content of DNA has impact on the behavior of the proteome, which is the main functional unit of cells, taking care of cell division, DNA repair, enzymatic reactions and signaling etc.

my question is: Are there different ways to categorize breast cancer based on protein expression data, with machine learning being used to classify them without using the pam50 proteins?


## Exploratory Data Analysis

loading of the dataframes and showing the successful loading and its dimensions.
note only the first 5 columns of "77_cancer_proteomes_CPTAC_itraq.csv" are shown since after column 4 they are the same type.
```{r data loading}

protein_exp_data <- read.csv(file = "Analysis//data//77_cancer_proteomes_CPTAC_itraq.csv")
clinical_data <- read.csv(file = "Analysis//data//clinical_data_breast_cancer.csv")
pam50_protein_data <- read.csv(file = "Analysis//data/PAM50_proteins.csv")

# showing succeseful loading of data

# only showing first 5 columns of proteomes
pander(head(protein_exp_data[1:5], n = 5))
pander(head(clinical_data, n=5))
pander(head(pam50_protein_data, n=5))

# showing the structure/dimensions of dataframe
cat("77_cancer_proteomes_CPTAC_itraq [ number of rows:", nrow(protein_exp_data), "number of columns:", ncol(protein_exp_data), '\n')
cat("clinical_data [ number of rows:", nrow(clinical_data), "number of columns:",ncol(clinical_data),'\n')
cat("pam50_protein_data [ number of rows:", nrow(pam50_protein_data), "number of columns:",ncol(pam50_protein_data),'\n')

```
Everything seems to be loaded completely, but we shall look further if everything is also correctly interpreted in R


Now checking if the protein expression data has been correctly read.
```{r Protein expression dataframe exploration}
str(protein_exp_data)
```
Nothing strange about the Proteomes dat everything seems to be read correct.

Checking if the clinical data  has been correctly read.
```{r clinical dataframe exploration}
str(clinical_data)
```
Nothing strange about the clinical data everything seems to be read correct.

Checking if the pam50 protein data  has been correctly read.
```{r pam 50 dataframe exploration}
str(pam50_protein_data)
```
Nothing strange about the pam50 protein data everything seems to be read correct.


### codebook

loading of the created codebooks for the three dataframes.
showing also its contents and successful loading
```{r code book visualisation}

cancer_proteomes_CPTAC_codebook <- read.csv2("Analysis//data/77_cancer_proteomes_CPTAC_codebook.txt")
clinical_data_codebook <- read.csv2("Analysis//data/clinical_data_breast_cancer_codebook.txt")
PAM50_protein_codebook <- read.csv2("Analysis//data/PAM50_protein_codebook.txt", sep = ";")


pander(cancer_proteomes_CPTAC_codebook)
pander(clinical_data_codebook)
pander(PAM50_protein_codebook)
```
Here we can also see that everything has been successfully loaded into R

## Data observation

there are 12553 rows in the data, these are proteins identifiable with a RefSeq ID number and have 86 columns of which the last 83 are samples(with their identifiers as there name and the last three from healthy individuals, but these shall not be used for the machine learning part since 3 samples is too little to use for analyzes.
to further use the data I shall reshape it to make the rows samples and each column a protein.

## Data cleaning and altering

### altering sample names

the alteration of sample names to corespondent to the clinical data names is needed for further comparison and analyses.
this is done by changing the column names to that of the same format of the clinical data.
this is done with some regex magic.
```{r sample name altering}
# storing a list of the column names
column_names <- names(protein_exp_data)

# function
change_sample_name <- function (x){
  #search for TCGA name,if found split and make new name
    if(grepl("TCGA",x) == TRUE){
      temp_list <- as.list(strsplit(x, '[_|-|.]')[[1]])
      x <- str_c(c('TCGA',temp_list[[1]],temp_list[[2]]),collapse = '-')
    }
return (x)
}

# changing of the colnames
colnames(protein_exp_data) <- lapply(column_names, change_sample_name)
cat("Old name:",column_names[[4]],",New name:",names(protein_exp_data)[[4]])

```
this output show to conversion has been successful

### numerical data frame
now  we need to make a data frame with only the numerical data for the ease of analyzes
```{r numerical dataframe}
# first making a data frame with only the numerical data, samples start at column number 4 til the end column number 86
protein_exp_numerical <- protein_exp_data[4:86]
```


### Transposing
transposing the created data frame "protein_exp_numerical", and adding the refseq ID as column name
```{r Data transposing}

# transposing of the old dataframe to a new one
protein_exp__numerical_transposed <- as.data.frame(t(protein_exp_numerical))
colnames(protein_exp__numerical_transposed) <- protein_exp_data$RefSeq_accession_number

# checking if succesfull
cat("protein_exp_numerical number of rows:", nrow(protein_exp_numerical),
    "number of columns:", ncol(protein_exp_numerical), '\n')
cat("protein_exp__numerical_transposed number of rows:", nrow(protein_exp__numerical_transposed),
    "number of columns:", ncol(protein_exp__numerical_transposed), '\n')


```
as we can see the row and column dimensions have been flipped

### cleaning

since there are NA values in the data lets see how much
```{r cleaning step for NA}
count_na_func <- function(x) sum(is.na(x))
# getting NA values per RefSeqID(column)
Na_per_col <- sapply(protein_exp__numerical_transposed, count_na_func)
```
```{r plot making1, fig.cap = "barplot with the frequency of columns with more than 0 NA in them", out.width = "90%"}

ggplot() +
  aes(Na_per_col) +
  geom_histogram(color = "black", fill = "#F9C000", binwidth = 3) +
  xlab("Number of NA") +
  ylab("Frequency of columns") +
  ggtitle("Frequency of number of NA values per RefSeqID")

ggsave(
  filename = "figure1.png",
  plot = last_plot(),
  path = "data/figures")

```
```{r plot making2 , fig.cap = "barplot with the frequency of columns with more than 0 NA in them", out.width = "90%"}
ggplot() +
  aes(Na_per_col[Na_per_col > 0]) +
  geom_histogram(color = "black", fill = "#0039F9",binwidth = 3) +
  xlab("Number of NA") +
  ylab("Frequency of columns") +
  ggtitle("Frequency of number of NA values per RefSeqID with 0 omitted")

ggsave(
  filename = "figure2.png",
  plot = last_plot(),
  path = "data/figures")

```
there are a lot of proteins with more than 10% of their samples with missing data, so i shall be removing.
```{r finishing NA cleaning}
cat("number of proteins with NA values in them:", sum(Na_per_col > 0), '\n' )

# deleting every protein with more than 10% NA values in them, since this is allot
proteomes_filtered_data <- protein_exp__numerical_transposed[Na_per_col < 8]
cat("number of proteins with 8 or more NA values in them and deleted from data:",
    sum(Na_per_col > 8), '\n')

cat("proteomes_filtered_data[number of rows:",
    nrow(proteomes_filtered_data),
    "number of columns:",
    ncol(proteomes_filtered_data),'\n')
```
as we can see from te reports generated by the code we can see that the filtering of NA was successful.
and we now have a data set that contains data with less than 10% per protein of NA values

### Merging clinical and protein expression dataframes

to be able to use the Clinical dat we need to merge it to its corresponding row and sample in the Protein expressions
```{r data merging}
# firs assigning row names to clinical data
rownames(clinical_data) <- clinical_data$Complete.TCGA.ID


# removing the used ID column to simplifie it since it has been become redundend
clinical_data <- clinical_data[,-1]

# mergin the two data frames according to the row names (TCGA Identification number),
merged_data <- merge(select(clinical_data, Tumor, Tumor..T1.Coded, AJCC.Stage, Vital.Status), protein_exp__numerical_transposed, by = 0)
cleaned_merged_data <- merge(select(clinical_data, Tumor, Tumor..T1.Coded, AJCC.Stage, Vital.Status), proteomes_filtered_data, by = 0)
cat("merged_data of rows:", nrow(merged_data),
    "number of columns:",ncol(merged_data),'\n')
```
we can see that not every sample had an entry in the clinical data, so we end up with 6 rows of sample data that get left out of the merged data set

## Data visualisation

Showing some examples of distributions of protein expression data since there are around 12 000 proteins found
```{r plot making3, fig.cap = "boxplot of protein expression distribution, first 70 proteins", out.width = "90%"}

# Open a png file
#png("../data/figures/figure3.png")
# 2. Create a plot
boxplot(merged_data[6:76],
        col = rainbow(ncol(merged_data[6:76])),
                           xlab = "Protein",
                           ylab = "log2 iTRAQ ratio",
                           main = "distribution of Protein expression for first 70 Proteins",
                           show.names= FALSE)
# Close the pdf file
#dev.off()
```

Since i can't be sure of the significant of every protein I can't simply trow away any sample

to fix this i shall get the standard deviation from every protein to prepare for a selection of the most deviant ones.
and for illustration i will overlay the dataframe which has been filtered from most NA values

```{r plot making4, fig.cap = "scatterplot of standard deviation for the protein expresion data and for the NA filterd version", out.width = "90%"}

fg <- colSds(as.matrix(merged_data[sapply(merged_data, is.numeric)]), na.rm = TRUE)
fg2 <- colSds(as.matrix(cleaned_merged_data[sapply(cleaned_merged_data, is.numeric)]), na.rm = TRUE)


fg <- as.data.frame(fg, row.names = colnames(merged_data[6:ncol(merged_data)]))
fg2 <- as.data.frame(fg2, row.names = colnames(cleaned_merged_data[6:ncol(cleaned_merged_data)]))

fg$count <- seq(from = 1, to = nrow(fg))

merged_fg <- merge(fg,fg2,all.x = TRUE, by = 0)
merged_fg <- merged_fg[order(merged_fg$count),]

# assigning 0 to every NA values in fg2 since that is the filterd one
merged_fg$fg2[is.na(merged_fg$fg2)] <- 0

# plotting
ggplot(data=merged_fg) +
  geom_point(size=0.0015, aes(x=count,  y=fg, color="Non Na filtered")) +
  geom_point(size=0.0015, aes(x=count,y=fg2,  color="Na filtered")) +
  labs(x = "Data Frame row number",
         y = "Standard deviation",
         color = "Legend") +
  ggtitle("Density plot for standard deviation of protein expression") +
  theme(legend.position = "bottom")

ggsave(
  filename = "figure4.png",
  plot = last_plot(),
  path = "data/figures")

```


as we can see in the standard deviation compared from proteins with a lot of samples with NA in them to the filtered data, we see that the proteins with a lot of NA in them seem to be having a higher Standard deviation, but still there should be enough deviation in the filtered Data.
```{r Assigning factors}
# assigning as factors
merged_data$Tumor <- factor(merged_data$Tumor)
cleaned_merged_data$Tumor <- factor(cleaned_merged_data$Tumor)
#merged_data$Row.names <- factor(merged_data$Row.names, levels =)
#cleaned_merged_data$Row.names <- factor(cleaned_merged_data$Row.names)
```
```{r plot figure , fig.cap = "distribution of amount of samples per tumor stage"}
plot(cleaned_merged_data$Tumor, ylab = "Count", xlab="tumor stage", col ="#F9C000", main = "distribution of tumor stage")
```


# Supervised Learning

In this chapter, we are looking at how we are going to train the machine learning algorithms to accurately predict the tumor stage of breast cancer according to the protein expressions found in breast tissue samples.
after that there shall be a examination of the result and accuracy of the created models accordingly to different algorithms.

## Weka

Weka is used for the data examination and machine learning part, Weka is a open source collection of machine learning algorithms for data mining tasks. It contains tools for data preparation, classification, regression, clustering, association rules mining, and visualization. java platform for
Firstly the data is exported to a .arff file so it can be loaded into Weka


### Data imbalance
```{r}
set.seed(420)


train <- createDataPartition(cleaned_merged_data$Tumor,
                             p = 0.7, # % of data going to training
                             times = 1,
                             list = F)
train.orig <- cleaned_merged_data[ train,]
test       <- cleaned_merged_data[-train,]

train.orig <- train.orig[,c(-1,-3:-5)]
test       <- test[,c(-1,-3:-5)]

train.orig$data.class <- as.factor(train.orig$Tumor)
test$data.class <- as.factor(test$Tumor)

train2 <- cleaned_merged_data[,c(-3:-5)]
train3 <- train2[,-2]
train2$data.class <- as.factor(train2$Tumor)
```
```{r Data exportation}
#train2 <- train2[,-1]
write.arff(train.orig, file = "data/train.orig.arff")
write.arff(test, file = "data/test_data.arff")
write.arff(train2, file = "data/train2.arff")
write.arff(train3, file = "data/train3.arff")
```
## Models

#### zeroR

The first algoritme used is a zeroR one is produced the following results
=== Summary ===

Correctly Classified Instances          51               66.2338 %
Incorrectly Classified Instances        26               33.7662 %
Kappa statistic                          0
Mean absolute error                      0.2665
Root mean squared error                  0.3613
Relative absolute error                100      %
Root relative squared error            100      %
Total Number of Instances               77

##### confusion matrix

=== Confusion Matrix ===

  a  b  c  d   <-- classified as
  0 10  0  0 |  a = T1
  0 51  0  0 |  b = T2
  0 11  0  0 |  c = T3
  0  5  0  0 |  d = T4

#### RandomTree

#####

#### RandomForest

#####

#### J48

#####

#### AttributeSelectedClassifier

##### J48 CfsSubsetEval GreedyStepwise

##### J48 CfsSubsetEval BestFirst Bi directional

##### J48 CfsSubsetEval BestFirst Forward

##### J48 ClassifierSubsetEval Ranker

#### Adaboost-M1 AttributeSelectedClassifier CfsSubsetEval Ranker

##### Randomforest  CfsSubsetEval BestFirst Bi-directrional

##### RandomTree  CfsSubsetEval BestFirst Bi-directrional
